import at from "./at";
import head from "./at/head";
import tail from "./at/tail";
import atRight from "./at/right";
import averageBy from "./average/by";
import averageOf from "./average/of";
import concat from "./concat";
import countOf from "./count/of";
import countBy from "./count/by";
import map from "./map";
import fill from "./fill";
import fillFull from "./fill/full";
import fillStart from "./fill/start";
import fillEnd from "./fill/end";
import filter from "./filter";
import find from "./find";
import findRight from "./find/right";
import findIndexRight from "./find/index/right";
import forEach from "./forEach";
import forEachRight from "./forEach/right";
import groupBy from "./groupBy";
import indexOf from "./indexOf";
import lastIndexOf from "./indexOf/last";
import isEmpty from "./is/empty";
import join from "./join";
import joinUp from "./join/up";
import joinBy from "./join/by";
import keyBy from "./keyBy";
import limit from "./limit";
import maximumBy from "./maximum/by";
import maximumOf from "./maximum/of";
import minimumBy from "./minimum/by";
import minimumOf from "./minimum/of";
import partition from "./partition";
import reduce from "./reduce";
import reduceRight from "./reduce/right";
import averageByContext from "./average/by/context";
import countByContext from "./count/by/context";
import countOfContext from "./count/of/context";
import countOfAnyContext from "./count/of/any/context";
import mapContext from "./map/context";
import maximumByContext from "./maximum/by/context";
import minimumByContext from "./minimum/by/context";
import { ArraySecondElement } from "./index.D";
/**
 * @example
 * const myNumberArray = new Array(2); // Array<number> -> [empty, empty];
 * myNumberArray.push(2);
 * myNumberArray.push(3);
 * myNumberArray; // [2, 3];
 *
 * const days = Array.of('san', 'mon', 'wen'); // Array<string> -> ['san', 'mon', 'wen'];
 */
export declare type ExtractPredicate<T extends Array<any, any[]>> = T extends Array<infer T, infer P> ? P : T extends Array<infer T> ? T[] : never;
declare class Array<T, Predicate extends T[] = T[]> extends globalThis.Array<T> implements ReadonlyArray<T> {
    get length(): Predicate['length'];
    at<Value extends number>(index: Value): Predicate extends [infer F, ...infer N] ? Predicate[Value] : (T | void);
    static readonly at: typeof at;
    static readonly atRight: typeof atRight;
    static readonly head: typeof head;
    static readonly tail: typeof tail;
    static readonly averageBy: typeof averageBy;
    static readonly averageOf: typeof averageOf;
    static readonly concat: typeof concat;
    static readonly countOf: typeof countOf;
    static readonly countBy: typeof countBy;
    static readonly fillFull: typeof fillFull;
    static readonly fillStart: typeof fillStart;
    static readonly fillEnd: typeof fillEnd;
    static readonly fill: typeof fill;
    static readonly filter: typeof filter;
    static readonly find: typeof find;
    static readonly findRight: typeof findRight;
    static readonly findIndex: typeof find;
    static readonly findIndexRight: typeof findIndexRight;
    static readonly forEach: typeof forEach;
    static readonly forEachRight: typeof forEachRight;
    static readonly groupBy: typeof groupBy;
    static readonly indexOf: typeof indexOf;
    static readonly lastIndexOf: typeof lastIndexOf;
    static readonly isEmpty: typeof isEmpty;
    static readonly join: typeof join;
    static readonly joinUp: typeof joinUp;
    static readonly joinBy: typeof joinBy;
    static readonly keyBy: typeof keyBy;
    static readonly limit: typeof limit;
    static readonly maximumBy: typeof maximumBy;
    static readonly maximumOf: typeof maximumOf;
    static readonly minimumBy: typeof minimumBy;
    static readonly minimumOf: typeof minimumOf;
    static readonly partition: typeof partition;
    static readonly map: typeof map;
    static readonly reduce: typeof reduce;
    static readonly reduceRight: typeof reduceRight;
    static of<T extends any[]>(...args: T): Array<T extends (infer U)[] ? U : any, T>;
    static from<T extends any[]>(fromArray: T): Array<T extends (infer U)[] ? U : any, T>;
    constructor(length?: number);
    averageBy: typeof averageByContext;
    countBy: typeof countByContext;
    countOf: typeof countOfContext;
    countOfAny: typeof countOfAnyContext;
    maximumBy: typeof maximumByContext;
    minimumBy: typeof minimumByContext;
    map: typeof mapContext;
    get head(): ArraySecondElement<Predicate>;
    get tail(): ArraySecondElement<Predicate>;
    get isEmpty(): boolean;
    get isNoEmpty(): boolean;
    get isUniq(): boolean;
    get uniq(): Array<T, T[]>;
}
export default Array;
export { default as at } from "./at";
export { default as averageBy } from "./average/by";
export { default as averageOf } from "./average/of";
export { default as concat } from "./concat";
export { default as countBy } from "./count/by";
export { default as countOf } from "./count/of";
export { default as fill } from "./fill";
export { default as filter } from "./filter";
export { default as find } from "./find";
export { default as map } from "./map";
